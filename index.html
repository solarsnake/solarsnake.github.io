<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Terminal Portfolio</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- jQuery -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
    <!-- jQuery Terminal -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.terminal/2.44.1/js/jquery.terminal.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/jquery.terminal/2.44.1/css/jquery.terminal.min.css" rel="stylesheet"/>
    <!-- Marked.js for Markdown parsing -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

    <style>
        /* Custom scrollbar for a more terminal-like feel */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #1e1e1e; /* Dark background for track */
        }
        ::-webkit-scrollbar-thumb {
            background: #555; /* Grey thumb */
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #777; /* Lighter grey on hover */
        }

        /* Basic body styling */
        body {
            font-family: 'Menlo', 'Monaco', 'Consolas', 'Courier New', monospace;
            background-color: #000000; /* Black background */
            color: #00FF00; /* Matrix green text */
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            line-height: 1.5;
        }

        /* Terminal container */
        .terminal-container {
            width: 100%;
            max-width: 100%; /* Full width */
            height: 100vh; /* Full viewport height */
            padding: 10px;
            box-sizing: border-box;
        }

        /* jQuery Terminal specific styles */
        .terminal, .cmd, .terminal .terminal-output, .terminal .terminal-output div, .terminal .terminal-output span {
            --color: #00FF00; /* Matrix green for text */
            --background: #000000; /* Black background */
            --prompt-color: #00FF00; /* Prompt color */
            --command-color: #00FF00; /* Command text color */
            --error-color: #FF4136; /* Bright red for errors */
            --link-color: #39CCCC;  /* Cyan for links */
            font-size: 1em; /* Base font size */
            line-height: 1.4;
            font-family: inherit; /* Inherit from body */
        }

        .terminal {
            background-color: var(--background) !important;
            padding: 5px;
            border: none !important;
            height: 100% !important; /* Ensure terminal takes full height of its container */
        }
        
        .terminal .cmd,
        .terminal .cmd > div,
        .terminal .cmd .prompt,
        .terminal .cmd .cursor,
        .terminal .cmd span[contenteditable="true"],
        .terminal .cmd input {
            background-color: transparent !important;
            color: var(--command-color) !important;
            border: none !important;
            box-shadow: none !important;
            outline: none !important;
            font-family: inherit !important;
            padding: 0 !important;
            margin: 0 !important;
            vertical-align: baseline;
        }

        .terminal .cmd .cursor.blink {
            background-color: var(--color) !important; 
            animation: terminal-blink 1s step-end infinite;
            display: inline-block;
            width: 0.6em; 
            height: 1.2em; 
            vertical-align: -0.15em; 
            margin-left: 1px;
            box-shadow: none !important;
            border: none !important;
        }
        
        .terminal a {
            color: var(--link-color) !important;
            text-decoration: underline;
            font-weight: bold;
        }
        .terminal a:hover {
            color: #FFFFFF !important;
            background-color: var(--link-color) !important;
        }

        .terminal-cat-content {
            background-color: #0a0a0a; 
            border-left: 3px solid #00FF00;
            padding: 10px 15px;
            margin: 10px 0;
            color: #00E600; 
            white-space: pre-wrap; 
            word-wrap: break-word;
        }
        .terminal-cat-content h1, .terminal-cat-content h2, .terminal-cat-content h3 {
            color: #00FF00;
            border-bottom: 1px solid #005000;
            padding-bottom: 5px;
            margin-top: 15px;
            margin-bottom: 10px;
        }
        .terminal-cat-content p { margin-bottom: 10px; }
        .terminal-cat-content ul, .terminal-cat-content ol { margin-left: 20px; margin-bottom: 10px; }
        .terminal-cat-content li { margin-bottom: 5px; }
        .terminal-cat-content code {
            background-color: #1a1a1a;
            padding: 2px 5px;
            border-radius: 3px;
            font-family: inherit;
        }
        .terminal-cat-content pre code {
            display: block;
            padding: 10px;
            overflow-x: auto;
        }
        .terminal-cat-content blockquote {
            border-left: 3px solid #008000; 
            padding-left: 10px;
            margin-left: 0;
            font-style: italic;
            color: #00cc00; 
        }

        .terminal .terminal-output > div > div {
            width: 100%;
            display: block;
            white-space: pre-wrap; 
            word-wrap: break-word; 
        }
        /* For help command formatting */
        .help-command {
            display: inline-block;
            width: 28ch; /* Adjusted width for longer commands with args */
            white-space: nowrap;
            vertical-align: top;
        }
        .help-description {
            display: inline-block;
            vertical-align: top;
            /* Allow description to wrap if it's very long */
            white-space: normal; 
            word-break: break-word;
        }

    </style>
</head>
<body class="bg-black text-green-400">
    <div id="terminal" class="terminal-container"></div>

    <script>
        // Handle bfcache page restore for back/forward navigation
        window.addEventListener('pageshow', function(event) {
            if (event.persisted) {
                // Page is loaded from the bfcache, force a reload
                window.location.reload();
            }
        });

        jQuery(function($, undefined) {
            // --- Configuration and Data ---
            const siteConfig = {
                title: "suǝddᴉʇ",
                username: "tippens",
                hostname: "dev.ops",
                github_username: "solarsnake", 
                linkedin_url: "https://www.linkedin.com/in/timothytippens/",
                email: "solarsnake88@proton.me", 
                baseurl: "" 
            };

            // Simulated file system (This is where 'ls /blog' gets its content)
            const filesystem = {
                '/': { type: 'dir', content: ['about.txt', 'resume.md', 'blog', 'contact.txt', 'projects'] },
                '/blog': { type: 'dir', content: ['post1-welcome.md', 'post2-deep-dive.md'] },
                '/projects': { type: 'dir', content: ['project-alpha.txt', 'project-beta.txt'] },
                '/about.txt': { type: 'file', content: `About Me:\nI am a passionate DevOps professional with a knack for automation and cloud technologies. This terminal is a showcase of my skills and a brief history of my career.\nType 'help' for a list of commands.` },
                '/resume.md': { type: 'file', content: `
Go ahead and type "resume" into the terminal to view a more well formatted resume, silly.
` },
                '/projects/project-alpha.txt': { type: 'file', content: 'Project Alpha: An automated deployment script for web applications using Ansible and Docker.'},
                '/projects/project-beta.txt': { type: 'file', content: 'Project Beta: A serverless image processing pipeline on AWS Lambda and S3.'},
            };

            let currentPath = '/';

            // --- Utility Functions ---
            function getAbsolutePath(path) {
                if (!path) return currentPath; 
                if (path.startsWith('/')) {
                    if (path !== '/' && path.endsWith('/')) {
                        return path.slice(0, -1);
                    }
                    return path;
                }
                const parts = currentPath.split('/').filter(p => p.length > 0);
                const pathParts = path.split('/').filter(p => p.length > 0);

                for (const part of pathParts) {
                    if (part === '..') {
                        if (parts.length > 0) {
                            parts.pop();
                        }
                    } else if (part !== '.') {
                        parts.push(part);
                    }
                }
                const newAbsPath = '/' + parts.join('/');
                if (newAbsPath !== '/' && newAbsPath.endsWith('/')) {
                    return newAbsPath.slice(0, -1);
                }
                return newAbsPath || '/';
            }

            function getFile(path) {
                const absolutePath = getAbsolutePath(path);
                return filesystem[absolutePath];
            }

            function renderMarkdown(markdown) {
                const html = marked.parse(markdown);
                return { html: `<div class="terminal-cat-content">${html}</div>`, raw: true };
            }
            
            // --- Terminal Initialization ---
            const term = $('#terminal').terminal(function(command, term) {
                const parts = command.trim().split(' ');
                const cmd = parts[0].toLowerCase();
                const args = parts.slice(1);
                const fullCommand = command.trim(); // Keep the original trimmed command for specific checks

                // --- Command Implementations ---
                if (cmd === 'help') {
                    term.echo('Available commands:');
                    const helpItems = [
                        { cmd: 'about', desc: 'Display information about this terminal.' },
                        { cmd: 'blog', desc: 'Navigate to the blog index page.' },
                        { cmd: 'cat &lt;file&gt;', desc: 'Display content of a file.' },
                        { cmd: 'cd &lt;directory&gt;', desc: 'Change current directory.' },
                        { cmd: 'clear', desc: 'Clear the terminal screen.' },
                        { cmd: 'contact', desc: 'Navigate to contact page.' },
                        { cmd: 'date', desc: 'Display the current date and time.' },
                        { cmd: 'echo &lt;text&gt;', desc: 'Display text.' },
                        { cmd: 'exit', desc: 'Close the terminal (simulated).' },
                        { cmd: 'home', desc: 'Navigate to the home page (this terminal).' },
                        { cmd: 'help', desc: 'Show this help message.' },
                        { cmd: 'history', desc: 'Show command history.' },
                        { cmd: 'ls [path]', desc: 'List files and directories.' },
                        { cmd: 'open &lt;file&gt;', desc: 'Open a file/page in a new tab/window.' },
                        { cmd: 'pwd', desc: 'Print working directory.' },
                        { cmd: 'resume', desc: 'Navigate to the resume page.' },
                        { cmd: 'social', desc: 'Display social media links.' },
                        { cmd: 'theme &lt;dark|light&gt;', desc: 'Change terminal theme (placeholder).' },
                        { cmd: 'welcome', desc: 'Display the welcome message.' },
                        { cmd: 'whoami', desc: 'Display current user.' }
                    ];
                    helpItems.forEach(item => {
                        const formattedCmd = $.terminal.format(`[[b;#00FF00;]${item.cmd}]`); 
                        const line = `  <span class="help-command">${formattedCmd}</span> <span class="help-description">- ${item.desc}</span>`;
                        term.echo(line, {raw: true});
                    });

                } else if (cmd === 'echo') {
                    term.echo(args.join(' '));
                } else if (cmd === 'clear') {
                    term.clear();
                    welcomeMessage(term);
                } else if (cmd === 'welcome') {
                    welcomeMessage(term);
                } else if (cmd === 'about') {
                    const file = getFile('/about.txt');
                    if (file && file.type === 'file') {
                        term.echo(file.content); 
                    } else {
                        term.error('about.txt not found.');
                    }
                } else if (cmd === 'social') {
                    term.echo('Connect with me:');
                    term.echo(`  GitHub:   [[!;;;;https://github.com/${siteConfig.github_username}]https://github.com/${siteConfig.github_username}]]`);
                    term.echo(`  LinkedIn: [[!;;;;${siteConfig.linkedin_url}]${siteConfig.linkedin_url}]]`);
                    term.echo(`  Email:    [[!;;;;mailto:${siteConfig.email}]${siteConfig.email}]]`);
                } else if (cmd === 'contact') {
                    term.echo('Navigating to contact page...');
                    window.location.href = siteConfig.baseurl + '/contact.html';
                } else if (cmd === 'resume') {
                    term.echo('Navigating to resume page...');
                    window.location.href = siteConfig.baseurl + '/resume.html';
                } else if (cmd === 'blog') {
                    term.echo('Navigating to blog index...');
                    window.location.href = siteConfig.baseurl + '/blog/index.html'; 
                } else if (cmd === 'home') {
                    term.echo('Navigating to home...');
                    window.location.href = siteConfig.baseurl + '/'; 
                } else if (cmd === 'ls') {
                    const pathToList = args[0] ? getAbsolutePath(args[0]) : currentPath;
                    const dir = getFile(pathToList);
                    if (dir && dir.type === 'dir') {
                        term.echo(`Contents of [[b;#FFFFFF;]${pathToList}]:`);
                        if (dir.content.length === 0) {
                            term.echo('  (empty)');
                        } else {
                            dir.content.forEach(item => {
                                const itemPath = (pathToList === '/' ? '' : pathToList) + '/' + item;
                                const entry = getFile(itemPath);
                                if (entry && entry.type === 'dir') {
                                    term.echo(`  [[b;#39CCCC;]${item}/]]`); 
                                } else {
                                    term.echo(`  ${item}`);
                                }
                            });
                        }
                    } else {
                        term.error(`ls: cannot access '${args[0] || pathToList}': No such file or directory`);
                    }
                } else if (cmd === 'cat') {
                    if (args.length === 0) {
                        term.error('Usage: cat <filename>');
                    } else {
                        const pathToFile = getAbsolutePath(args[0]);
                        const file = getFile(pathToFile);
                        if (file && file.type === 'file') {
                            if (pathToFile.endsWith('.md')) {
                                const {html, raw} = renderMarkdown(file.content);
                                term.echo(html, {raw: raw});
                            } else {
                                term.echo(file.content);
                            }
                        } else {
                             term.error(`cat: ${args[0]}: No such file or directory`);
                        }
                    }
                } else if (cmd === 'open') {
                    if (args.length === 0) {
                        term.error('Usage: open <filepath>');
                        return;
                    }
                    const pathToFile = getAbsolutePath(args[0]);
                    const file = getFile(pathToFile);

                    if (file && file.type === 'file') {
                        let targetUrl = '';
                        if (pathToFile.startsWith('/blog/')) {
                            const slug = pathToFile.substring('/blog/'.length).replace('.md', '');
                            targetUrl = `${siteConfig.baseurl}/blog/${slug}.html`;
                        } else if (pathToFile === '/resume.md') {
                             targetUrl = `${siteConfig.baseurl}/resume.html`;
                        } else if (pathToFile === '/contact.txt') { 
                             targetUrl = `${siteConfig.baseurl}/contact.html`;
                        }
                        
                        if (targetUrl) {
                            term.echo(`Opening ${args[0]} in a new tab...`);
                            window.open(targetUrl, '_blank');
                        } else {
                            term.echo(`Don't know how to open '${args[0]}' directly. Try 'cat ${args[0]}'.`);
                        }
                    } else {
                        term.error(`open: ${args[0]}: No such file or directory`);
                    }

                } else if (cmd === 'cd') {
                    if (args.length === 0 || args[0] === '~' || args[0] === '') {
                         currentPath = '/'; 
                    } else {
                        const newPath = getAbsolutePath(args[0]);
                        const dir = getFile(newPath);
                        if (dir && dir.type === 'dir') {
                            currentPath = newPath;
                        } else {
                            term.error(`cd: ${args[0]}: No such file or directory`);
                        }
                    }
                    term.set_prompt(getPrompt());
                } else if (cmd === 'pwd') {
                    term.echo(currentPath);
                } else if (cmd === 'whoami') {
                    term.echo(siteConfig.username);
                } else if (cmd === 'date') {
                    term.echo(new Date().toString());
                } else if (cmd === 'history') {
                    term.history().data().forEach((h, i) => term.echo(`${String(i).padStart(3, ' ')}: ${h}`));
                } else if (cmd === 'theme') {
                    term.echo("Theme functionality not yet implemented.");
                } else if (cmd === 'exit') {
                    term.echo("Simulating exit. Goodbye!");
                } else if (fullCommand === 'rm -rf *' || fullCommand === 'rm -rf /') {
                    // Easter egg for "rm -rf *"
                    term.echo("⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠋⠁⠀⠀⠈⠉⠙⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿");
                    term.echo("⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿");
                    term.echo("⣿⣿⣿⣿⣿⣿⣿⣿⡟⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢻⣿⣿⣿⣿⣿⣿⣿");
                    term.echo("⣿⣿⣿⣿⣿⣿⣿⡟⠀⠀⠀⠀⠀⢀⣠⣤⣤⣤⣤⣄⠀⠀⠀⠹⣿⣿⣿⣿⣿⣿");
                    term.echo("⣿⣿⣿⣿⣿⣿⣿⠁⠀⠀⠀⠀⠾⣿⣿⣿⣿⠿⠛⠉⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿");
                    term.echo("⣿⣿⣿⣿⣿⣿⡏⠀⠀⠀⣤⣶⣤⣉⣿⣿⡯⣀⣴⣿⡗⠀⠀⠀⠀⣿⣿⣿⣿⣿");
                    term.echo("⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⡈⠀⠀⠉⣿⣿⣶⡉⠀⠀⣀⡀⠀⠀⠀⢻⣿⣿⣿⣿");
                    term.echo("⣿⣿⣿⣿⣿⣿⡇⠀⠀⠸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠇⠀⠀⠀⢸⣿⣿⣿⣿");
                    term.echo("⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠉⢉⣽⣿⠿⣿⡿⢻⣯⡍⢁⠄⠀⠀⠀⣸⣿⣿⣿⣿");
                    term.echo("⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠐⡀⢉⠉⠀⠠⠀⢉⣉⠀⡜⠀⠀⠀⠀⣿⣿⣿⣿⣿");
                    term.echo("⣿⣿⣿⣿⣿⣿⠿⠁⠀⠀⠀⠘⣤⣭⣟⠛⠛⣉⣁⡜⠀⠀⠀⠀⠀⠛⠿⣿⣿⣿");
                    term.echo("⡿⠟⠛⠉⠉⠀⠀⠀⠀⠀⠀⠀⠈⢻⣿⡀⠀⣿⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉");
                    term.echo("⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠁⠀⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀");                    
                    term.echo("  [[b;orange;]Hey, careful there Boris! ;)]");
                    term.echo("  Why are you trying to erase my site?");
                }
                else if (command.trim() !== '') {
                    term.error(`${cmd}: command not found`); // Removed explicit red formatting
                }
            }, {
                greetings: false,
                prompt: getPrompt(),
                name: 'portfolio_terminal',
                onInit: function(term) {
                    welcomeMessage(term);
                    term.focus(true);
                },
                convertLinks: true,
                historySize: 200,
                scrollOnOutput: true,
                outputLimit: 100, 
                tabcompletion: true,
                completionEscape: false, 
                completion: function(string) {
                    const command = this.get_command();
                    const parts = command.split(/(\s+)/); 
                    const cmdName = parts[0].toLowerCase();
                    
                    let currentArgInput = string;
                    if (parts.length > 1) {
                        let lastPart = parts[parts.length - 1];
                        if (command.endsWith(' ')) { 
                            currentArgInput = "";
                        } else {
                           currentArgInput = lastPart;
                        }
                    }

                    let list = [];
                    const commands = ['help', 'echo', 'clear', 'welcome', 'about', 'social', 'contact', 'resume', 'blog', 'ls', 'cat', 'cd', 'pwd', 'whoami', 'date', 'history', 'theme', 'exit', 'open', 'home'];

                    if (parts.length <= 1 || (parts.length > 1 && command.lastIndexOf(' ') === command.length -1 && string === '')) { 
                         if (command.lastIndexOf(' ') === command.length -1 && string === ''){ 
                            const dirEntry = getFile(currentPath);
                            if (dirEntry && dirEntry.type === 'dir') {
                                list = dirEntry.content.map(item => {
                                    const itemPath = (currentPath === '/' ? '' : currentPath) + '/' + item;
                                    const itemEntry = getFile(itemPath);
                                    return item + (itemEntry && itemEntry.type === 'dir' ? '/' : '');
                                });
                            }
                        } else {
                            list = commands.filter(cmd => cmd.startsWith(string));
                        }
                    } else if (['cat', 'ls', 'cd', 'open'].includes(cmdName)) {
                        const pathPrefixMatch = currentArgInput.match(/^(.*\/)/);
                        const pathPrefix = pathPrefixMatch ? pathPrefixMatch[0] : '';
                        const partialName = currentArgInput.substring(pathPrefix.length);
                        
                        const dirToList = getAbsolutePath(pathPrefix || currentPath);
                        const dirEntry = getFile(dirToList);

                        if (dirEntry && dirEntry.type === 'dir') {
                            list = dirEntry.content
                                .filter(item => item.startsWith(partialName))
                                .map(item => {
                                    const fullItemPath = (dirToList === '/' && !pathPrefix) ? `/${item}` : (pathPrefix + item);
                                    const itemEntry = getFile(getAbsolutePath(fullItemPath)); 
                                    return pathPrefix + item + (itemEntry && itemEntry.type === 'dir' ? '/' : '');
                                });
                        }
                    }
                    return list;
                }
            });

            // --- Helper Functions for Terminal ---
            function getPrompt() {
                return `[[b;#00FF00;]${siteConfig.username}@${siteConfig.hostname}]` + 
                       `[[;#FFFFFF;]:${currentPath === '/' ? '~' : currentPath}]$ `;
            }

            function welcomeMessage(termInstance) {
                termInstance.echo(`Welcome to [[b;#00FF00;]${siteConfig.title} OS]] (v1.0.1)`);
                termInstance.echo(`Type '[[b;#00FF00;]help]' for a list of available commands.`);
                termInstance.echo('---');
            }

            // Re-focus terminal on document click if the click is not on an interactive element
            // and the terminal is not already focused.
            $(document).on('click', function(event) {
                if (!term.enabled()) { 
                    return;
                }
                const $target = $(event.target);
                // Check if the click is outside the terminal div, or if it's inside but not on an interactive element.
                if (!$target.closest('#terminal').length || 
                    ($target.closest('#terminal').length && !$target.is('a, button, input, textarea, [contenteditable="true"]') && !$target.closest('a, button').length)) {
                    
                    const activeTerminal = $.terminal.active();
                    if (!activeTerminal || activeTerminal[0] !== term[0]) {
                         term.focus(true);
                    }
                }
            });
        });
    </script>
</body>
</html>
